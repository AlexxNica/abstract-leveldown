// Generated by CoffeeScript 1.8.0
(function() {
  var AbstractError, AbstractIterator, AlreadyEndError, AlreadyRunError, Errors, InvalidArgumentError, NotImplementedError, inherits, isArray, util;

  util = require("abstract-object/lib/util");

  inherits = util.inherits;

  isArray = util.isArray;

  Errors = require("./abstract-error");

  AbstractError = Errors.AbstractError;

  NotImplementedError = Errors.NotImplementedError;

  InvalidArgumentError = Errors.InvalidArgumentError;

  AlreadyEndError = Errors.AlreadyEndError;

  AlreadyRunError = Errors.AlreadyRunError;

  module.exports = AbstractIterator = (function() {
    AbstractIterator.AlreadyEndError = AlreadyEndError;

    AbstractIterator.AlreadyRunError = AlreadyRunError;

    function AbstractIterator(db, options) {
      this.db = db;
      this.options = options;
      this._ended = false;
      this._nexting = false;
      if (options && isArray(options.range)) {
        this._resultOfKeys = options.range;
        this._indexOfKeys = -1;
      }
    }

    AbstractIterator.prototype._next = function(callback) {
      var self;
      self = this;
      if (this._nextSync) {
        return setImmediate(function() {
          var e, result;
          try {
            result = self._nextSync();
            self._nexting = false;
            if (result) {
              return callback(null, result[0], result[1]);
            } else {
              return callback();
            }
          } catch (_error) {
            e = _error;
            self._nexting = false;
            return callback(e);
          }
        });
      } else {
        return setImmediate(function() {
          self._nexting = false;
          return callback();
        });
      }
    };

    AbstractIterator.prototype._end = function(callback) {
      var self;
      self = this;
      if (this._endSync) {
        return setImmediate(function() {
          var e, result;
          try {
            result = self._endSync();
            return callback(null, result);
          } catch (_error) {
            e = _error;
            return callback(e);
          }
        });
      } else {
        return setImmediate(function() {
          return callback();
        });
      }
    };

    AbstractIterator.prototype.nextSync = function() {
      var result;
      if (this._ended) {
        throw new AlreadyEndError("cannot call next() after end()");
      }
      if (this._nexting) {
        throw new AlreadyRunError("cannot call next() before previous next() has completed");
      }
      if (this._indexOfKeys != null) {
        this._nexting = true;
        if (this._indexOfKeys === -1) {
          this._resultOfKeys = this.db._mGetSync(this._resultOfKeys, this.options);
          this._indexOfKeys++;
        }
        result = this._indexOfKeys >= 0 && this._indexOfKeys < this._resultOfKeys.length;
        if (result) {
          result = {
            key: this._resultOfKeys[this._indexOfKeys],
            value: this._resultOfKeys[++this._indexOfKeys]
          };
          this._indexOfKeys++;
        }
        this._nexting = false;
        return result;
      } else if (this._nextSync) {
        this._nexting = true;
        result = this._nextSync();
        if (result !== false) {
          result = {
            key: result[0],
            value: result[1]
          };
        }
        this._nexting = false;
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractIterator.prototype.endSync = function() {
      if (this._indexOfKeys != null) {
        this._resultOfKeys = null;
        this._indexOfKeys = -2;
        this._ended = true;
      } else if (this._endSync) {
        this._ended = true;
        return this._endSync();
      }
      throw new NotImplementedError();
    };

    AbstractIterator.prototype.next = function(callback) {
      var result, self;
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("next() requires a callback argument");
      }
      if (this._ended) {
        return callback(new AlreadyEndError("cannot call next() after end()"));
      }
      if (this._nexting) {
        return callback(new AlreadyRunError("cannot call next() before previous next() has completed"));
      }
      if (this._indexOfKeys != null) {
        this._nexting = true;
        if (this._indexOfKeys === -1) {
          self = this;
          this.db._mGet(this._resultOfKeys, this.options, function(err, arr) {
            self._nexting = false;
            if (err) {
              return callback(err);
            }
            self._resultOfKeys = arr;
            self._indexOfKeys++;
            return self.next(callback);
          });
          return;
        } else if (this._indexOfKeys >= 0 && this._indexOfKeys < this._resultOfKeys.length) {
          result = this._resultOfKeys.slice(this._indexOfKeys, this._indexOfKeys += 2);
          this._nexting = false;
        } else {
          result = false;
        }
        this._nexting = false;
        if (result === false) {
          return callback();
        } else {
          return callback(void 0, result[0], result[1]);
        }
      } else {
        this._nexting = true;
        self = this;
        return this._next(function() {
          self._nexting = false;
          return callback.apply(null, arguments);
        });
      }
    };

    AbstractIterator.prototype.end = function(callback) {
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("end() requires a callback argument");
      }
      if (this._ended) {
        return callback(new AlreadyEndError("end() already called on iterator"));
      }
      if (this._indexOfKeys != null) {
        this._ended = true;
        this._resultOfKeys = null;
        this._indexOfKeys = -2;
        return setImmediate(callback);
      } else {
        this._ended = true;
        return this._end(callback);
      }
    };

    return AbstractIterator;

  })();

}).call(this);
